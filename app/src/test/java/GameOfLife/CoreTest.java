/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package GameOfLife;

import org.checkerframework.checker.units.qual.C;
import org.junit.Test;

import java.util.Arrays;

import static org.junit.Assert.*;

//cloc Blueprint.java
//-------------------------------------------------------------------------------
//Language                     files          blank        comment           code
//-------------------------------------------------------------------------------
//Java                             1              3              0             15
//-------------------------------------------------------------------------------

//cloc Core.java
//-------------------------------------------------------------------------------
//Language                     files          blank        comment           code
//-------------------------------------------------------------------------------
//Java                             1             20              3            147
//-------------------------------------------------------------------------------
//
// 15 + 147 = 162 Zeilen
// => 17 Tests

public class CoreTest {

    @Test
    // Neu Instanziertes Spielfeld soll keine lebenden Zellen beinhalten
    public void newCoreFieldIsEmpty() {
        Core c = new Core(5, 5);

        assertTrue(c.getAliveCells().size() == 0);
    }

    @Test
    // Simulierter Mausklick bringt gewünschtes Ergebnis
    public void simulateMouseClick() {
        Core c = new Core(5, 5);
        c.switchCell(2, 2);

        String field = "     \n     \n  X  \n     \n     \n";
        assertTrue(c.toString().equals(field));
    }

    @Test
    // Überprüfen ob die erste Regel (Jede lebendige Zelle mit weniger als zwei Nachbarn stirbt) beachtet wird
    public void checkRuleOne() {
        Core c = new Core(5, 5);
        c.switchCell(2, 2);

        c.calculateStep();

        assertTrue(c.getAliveCells().size() == 0);
    }

    @Test
    // Überprüfen ob die zweite Regel (Jede lebendige Zelle mit mehr als vier Nachbarn stirbt) beachtet wird
    public void checkRuleTwo() {
        Core c = new Core(10, 10);
        c.switchCell(0, 0);
        c.switchCell(1, 0);
        c.switchCell(2, 0);
        c.switchCell(0, 1);
        c.switchCell(2, 1);
        c.switchCell(1, 1);

        c.calculateStep();

        assertFalse(c.getSingleCell(1, 1).getStatus());
    }

    @Test
    // Überprüfen ob die dritte Regel (Jede lebendige Zelle mit genau 2 oder 3 Nachbarn überlebt) beachtet wird
    public void checkRuleThree() {
        Core c = new Core(10, 10);
        c.switchCell(0, 1);
        c.switchCell(1, 1);
        c.switchCell(2, 1);

        c.calculateStep();

        assertTrue(c.getSingleCell(1, 1).getStatus());
    }

    @Test
    // Überprüfen ob die vierte Regel (Jede tote Zelle mit genau 3 Nachbarn wird wiederbelebt) beachtet wird
    public void checkRuleFour() {
        Core c = new Core(10, 10);
        c.switchCell(0,1);
        c.switchCell(1, 1);
        c.switchCell(2, 1);

        c.calculateStep();

        assertTrue(c.getSingleCell(1, 0).getStatus());
        assertTrue(c.getSingleCell(1, 2).getStatus());
    }

    @Test
    // Mehrere Zellen werden richtig gerendert
    public void cellsGetDisplayedCorrect() {
        Core c = new Core(5, 5);
        c.switchCell(2, 2);
        c.switchCell(2,3);
        c.switchCell(2, 1);

        String field = "     \n     \n XXX \n     \n     \n";
        assert(c.toString().equals(field));
    }


    @Test
    // Die nächste Generation wird richtig berechnet und die Zellen werden folglich richtig anzeigt
    public void cellsGetDisplayedCorrectInNextGeneration() {
        Core c = new Core(5, 5);
        c.switchCell(2, 2);
        c.switchCell(2,3);
        c.switchCell(2, 1);

        c.calculateStep();

        String field = "     \n  X  \n  X  \n  X  \n     \n";
        assert(c.toString().equals(field));
    }


    @Test
    // Die Blueprints können geladen werden
    public void blueprintsLoadingSuccessFull() {
        Core c = new Core(10, 10);
        Blueprint[] blueprints = c.loadBlueprints();
        assert(blueprints != null);
        assert(blueprints.length != 0);
    }


    @Test
    // Test ob Blueprint richtig angewandt wird
    public void blueprintAppliesCorrect() {
        Core c = new Core(10, 10);
        Blueprint[] blueprints = c.loadBlueprints();
        c.applyBlueprint(Arrays.asList(c.getBluePrintNames()).indexOf("glider"));

        assertTrue(c.getSingleCell(5, 5).getStatus());
        assertTrue(c.getSingleCell(6, 6).getStatus());
        assertTrue(c.getSingleCell(6, 7).getStatus());
        assertTrue(c.getSingleCell(5, 7).getStatus());
        assertTrue(c.getSingleCell(7, 6).getStatus());
        assertEquals(5, c.getAliveCells().size());
    }

    @Test
    // Wenn das Spielfeld leer ist, soll kein Blueprint erstellt werden
    public void doNotSaveEmptyBlueprint() {
        Core c = new Core(10, 10);

        String res = c.writeBlueprint();

        assert res == null;
    }

    @Test
    // Valider Blueprint wird geschrieben
    public void writeBlueprint() {
        Core c = new Core(50, 50);
        int size = c.getBluePrintNames().length;
        c.switchCell(10, 10);
        c.switchCell(10, 11);
        c.switchCell(10, 12);

        String newBlueprint = c.writeBlueprint();

        assert size + 1 == c.getBluePrintNames().length;
        assertNotEquals(-1, Arrays.asList(c.getBluePrintNames()).indexOf(newBlueprint));

    }

    @Test
    // Generationen werden richtig mitgezählt
    public void correctGenerationCount() {
        Core c = new Core(10, 10);

        assert(c.getGeneration() == 0);

        c.calculateStep();
        c.calculateStep();
        c.calculateStep();
        c.calculateStep();
        c.calculateStep();

        assert(c.getGeneration() == 5);

    }

    @Test
    // Reset funktioniert
    public void resetWorks() {
        Core c = new Core(10, 10);
        c.switchCell(1, 1);
        c.switchCell(1, 2);
        c.switchCell(1, 3);
        c.switchCell(3, 4);

        c.resetBoard();

        assert c.getAliveCells().size() == 0;
    }
    // Nachbarn werden richtig gezählt
    @Test public void getCorrectNeighborCount() {
        Core c = new Core(10, 10);

        assertEquals(0, c.getNeighborCount(1, 1));
    }

    @Test
    // Test ob der Deep-Copy Algorithmus funktioniert
    public void deepCopyWorks() {
        Core c = new Core(10, 10);
        Cell[][] board = new Cell[10][10];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = new Cell(i, j);
            }
        }
        board[1][1].switchStatus();
        Cell[][] copy = c.copyOf(board);

        assertNotSame(board, copy);
        assert(board[1][1].getStatus());
        assert(board[1][1].getStatus() == copy[1][1].getStatus());
        assertNotSame(board[1][1], copy[1][1]);
    }

    @Test
    // Test ob Daten richtig in der Blueprint Klasse gespeichert werden
    public void constructorWorking() {
        String name = "glider";
        int[][] values = new int[][] {{1, 1}, {1, 2}, {1, 4}, {1, 5}};
        Blueprint blueprint = new Blueprint(name, values);

        assert blueprint.getName().equals(name);
        assert Arrays.deepEquals(blueprint.getValues(), values);
    }
}
