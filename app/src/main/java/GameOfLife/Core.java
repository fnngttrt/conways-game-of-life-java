/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package GameOfLife;

import com.google.gson.Gson;

import java.awt.*;
import java.io.Reader;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


public class Core implements GameLogic {
    private int width;
    private int height;
    private final int border = 10;
    private int generation;
    private Cell[][] board;
    private Blueprint[] bluePrints;

    public Core(int width, int height) {
        this.width = width + border * 2;
        this.height = height + border * 2;
        board = new Cell[this.height][this.width];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = new Cell(i, j);
            }
        }
        bluePrints = loadBlueprints();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        for (int i = border; i < board.length-border; i++) {
            for (int j = border; j < board[i].length-border; j++) {
                res.append(board[i][j].getAsString());
            }
            res.append('\n');
        }
        return res.toString();
    }

    public void resetBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j].kill();
            }
        }
        generation = 0;
    }

    public Cell getSingleCell(int x, int y) {
        return board[x+border][y+border];
    }

    public int getGeneration
            () {
        return generation;
    }

    public void switchCell(int x, int y) {
        board[x+border][y+border].switchStatus();
    }

    public void switchCell(int[] x) {
        switchCell(x[0], x[1]);
    }

    public String[] getBluePrintNames() {
        return Arrays.stream(bluePrints).map(Blueprint::getName).toArray(String[]::new);
    }

    public void applyBlueprint(int blueprintId) {
        resetBoard();
        try {
            Arrays.stream(bluePrints[blueprintId].getValues()).peek(this::switchCell).collect(Collectors.toList());
        }
        catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Wrong Dimensions for Blueprint!");
        }
    }

    public String writeBlueprint() {
        List<Cell> aliveCells = getAliveCells();
        if (aliveCells.size() == 0) {
            return null;
        }
        int[][] positions = new int[aliveCells.size()][2];
        List<Point> a = aliveCells.stream().map(Cell::getPos).collect(Collectors.toList());
        for (int i = 0; i < aliveCells.size(); i++) {
            positions[i] = new int[] {a.get(i).x - border, a.get(i).y - border};
        }
        Blueprint[] temp = new Blueprint[bluePrints.length + 1];
        for (int i = 0; i < bluePrints.length; i++) {
            temp[i] = bluePrints[i];
        }
        temp[bluePrints.length] = new Blueprint("blueprint_" + bluePrints.length, positions);
        Gson gson = new Gson();
        try {
            Writer writer = Files.newBufferedWriter(Paths.get("src", "main", "resources", "blueprints.json"));
            gson.toJson(temp, writer);
            writer.close();
        }
        catch (Exception e) {
            System.out.println("File not found");
        }
        bluePrints = temp;
        return "blueprint_" + (bluePrints.length-1);
    }

    //Package-Private for Testing
    Blueprint[] loadBlueprints() {
        try {
            Gson gson = new Gson();
            Reader reader = Files.newBufferedReader(Paths.get("src", "main", "resources", "blueprints.json"));
            Blueprint[] bpts = gson.fromJson(reader, Blueprint[].class);
            reader.close();
            return bpts;
        } catch (Exception c) {
            System.out.println(c);
        }
        return null;
    }

    public void calculateStep() {
        Cell[][] tempBoard = copyOf(board);
        for (int i = 1; i < board.length - 1; i++) {
            for (int j = 1; j < board[i].length - 1; j++) {
                int neighbors = getNeighborCount(i, j);
                if (board[i][j].getStatus() && neighbors < 2) {
                    tempBoard[i][j].kill();
                }
                else if (board[i][j].getStatus() && neighbors > 3) {
                    tempBoard[i][j].kill();
                }
                else if (!board[i][j].getStatus() && neighbors == 3) {
                    tempBoard[i][j].revive();
                }
            }
        }
        board = copyOf(tempBoard);
        generation++;
    }
    //Package-Private for Testing
    Cell[][] copyOf(Cell[][] x) {
        Cell[][] y = new Cell[x.length][x[0].length];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                y[i][j] = new Cell(i, j).setStatus(x[i][j].getStatus());
            }
        }
        return y;
    }

    public int getNeighborCount(int x, int y) {
        return board[x+1][y-1].getAsInt() + board[x+1][y].getAsInt() + board[x+1][y+1].getAsInt() + board[x][y-1].getAsInt() + board[x][y+1].getAsInt() +board[x-1][y-1].getAsInt() + board[x-1][y].getAsInt() + board[x-1][y+1].getAsInt();
    }

    public List<Cell> getAliveCells() {
        return Arrays.stream(board).flatMap(Arrays::stream).filter(Cell::getStatus).collect(Collectors.toList());
    }

}
